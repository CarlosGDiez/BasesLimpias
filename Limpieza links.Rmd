---
title: "limpieza de variables"
author: '20180898'
date: "22/9/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown
Hay dos variables a trabajra se inciara con GEE y luego el indice de rigurosidad de Oxford.
GEE
```{r}
library(rio)

link5="https://github.com/CarlosGDiez/BasesLimpias/raw/master/Gee_sucio.csv"

data6=import(link5)
dim(data6)
```

Limpieza:
```{r}
library(readr)
library(lubridate)
library(plyr)
library(dplyr) #creo que solo requiero una de estas pero  no estoy seguro de cual
names(data6)[1]="Country"
names(data6)[3]="Series"

Prueba5=data6%>%
  group_by(Country)%>%
  mutate(Index = ifelse(Series==nth(Series,1), 1, 0))%>%
  filter(Index==0)
Prueba6=data6%>%
  group_by(Country)%>%
  mutate(Index = ifelse(Series==nth(Series,1), 1, 0))%>%
  filter(Index==1)
#eliminamos filas vacías
Prueba6=Prueba6[-c(215,216,217,218,219),]
Prueba6$std=Prueba5$`2018 [YR2018]`
str(Prueba6$`2018 [YR2018]`)
names(Prueba6)[5]="Indice"
  Prueba6$Indice=parse_number(Prueba6$Indice)
  #eliminamos filas sin valores
  
Prueba6=Prueba6[-c(46,129,139,144,164),]

Prueba6$std=parse_number(Prueba6$std)
str(Prueba6$Indice)
Prueba6$Indice=as.numeric(Prueba6$Indice)
str(Prueba6$Indice)
Prueba6$Limitesup=Prueba6$Indice+Prueba6$std
Prueba6$Limiteinf=Prueba6$Indice-Prueba6$std
#No se como unirlo sen un intervalo así que se quedan como dos limites
```


Limpieza adicional. Es útil reducir todo solo a código de país e indice, pero puede que el nombre siga siendo útil, para explicar cual es el código, en todo caso hay que reducrilo por si acaso todo a eso porque solo debe haber una key.
```{r}

Prueba6$Country=NULL
Prueba6$Series=NULL
Prueba6$Index=NULL
Prueba6$`Series Code`=NULL
Prueba6$std=NULL
#lo reducimos entonces al cofigo d epais, el indice, su limite inferior y superior.
write.table(Prueba6, file = "GEE_limpio.csv", sep = ",", quote = FALSE, row.names = F)
#write csv es que usa le profesor. veamos como queda?
write.csv(Prueba6, file = "GEE_limpio.csv", row.names = F)
Gee=import("GEE_limpio.csv")
#no parece haber diferencias notables
```

###
Indice de que tan estrictas son las medidas.

###
```{r}
link="https://github.com/CarlosGDiez/BasesLimpias/blob/master/Rigurosidad.csv?raw=true"
library(rio)

data=import(link)
dim(data)

```

#inicamos limpieza
```{r}


#Y si queremos el stringency index  no más?
data7=data
data7[6:34]=NULL
data7[7:15]=NULL
data7$RegionCode=NULL
data7$RegionName=NULL #estamos tomando medidas a nivel de pais, no local
data7$Date <- ymd(data7$Date)

```
Ahora queremos quedarnos solo a partir de la fecha de incio. Recurrimos a la varaible depedniente sobre casso al dia.



```{r}
#la primera parte de esto provienede los datos de Jose Incio.

confirmed <- "https://raw.github.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv"
##############
WorldData<-import(file = confirmed)%>%
  mutate(type="datacon")%>% 
  tidyr::gather(Fecha,Valor,-c(type,"Province/State",
                        "Country/Region",Lat,Long))   #juntando fechas distintas en una sola.

Prueba1= WorldData%>%
  filter(Valor>0)
#juntando provincias en paises
names(Prueba1)[2]="Country"
Prueba1=aggregate(Valor # dependientes
          ~ Country + Fecha, # nivel
          data = Prueba1,    # data
          sum)       # operacion

#hay un problema tiene paises requerimos códigos, un simple merge de paises y codigos para alinearlo
data3=data7
data3$Date=NULL
data3$GovernmentResponseIndex=NULL
data3$RegionName=NULL
data3$StringencyIndex=NULL
names(data3)[1]="Country"
#eliminamos paises repetidos. #advertencia algunas veces esta parte es lenta en leer, o lo era nates,a hora corre rapido
data3=data3[!duplicated(data3$Country),]
#aplciaremos Merge más adelante


#calcular dia 30
Prueba30=Prueba1%>%
  group_by(Country)%>%
  mutate(dia30 = ifelse(Fecha==nth(Fecha,30), 1, 0))%>%
  filter(dia30==1)

#Habiendo hecho eso procedemos a repetirlo pero con el dia 7
Prueba7=Prueba1%>%
  group_by(Country)%>%
  mutate(dia7 = ifelse(Fecha==nth(Fecha,7), 1, 0))%>%
  filter(dia7==1)

Prueba7$Fecha=mdy(Prueba7$Fecha)
str(Prueba7$Fecha)
Prueba7$Fecha=as.Date(Prueba7$Fecha)
#Perfecto ahora tenemos una base que solo tien paises (key) y codigos
Prueba7b=merge(Prueba7,data3, by.x="Country", by.y="Country")

str(Prueba7b$Fecha)


```
Ahora creamos varaibles mergeables


```{r}
library(stringr)
#creoe sta libraria e sun rezago de un intento anterior pero no me aatrevo a eliminarla

Prueba7b$DIA7=paste(Prueba7b$CountryCode,Prueba7b$Fecha)
Prueba7b$Country=NULL
Prueba7b$dia7=NULL
Prueba7b$CountryCode=NULL #Duele eliminarlo después de trabajr tanto para crarlo

data7$DIA7=paste(data7$CountryCode,data7$Date)
data7$Date=NULL
head(data7)
#Con stringecy


#data2$CountryName=NULL, este comando sera una opcion a futuro pero por ahora que uno conserve nombre no es mala idea, si nada más para saber a que diminutivo obedece cada pais

ResGob=merge(Prueba7b,data7, by.x="DIA7", by.y = "DIA7")
#eliminamos valores ya no necesario como el mismo DIA 7 y es tan frustrante eliminarlo despues de tanto esfuerzo.
ResGob$DIA7=NULL
#El valor ya no es necesario es parte de la variable dependiente no de  esta independeinte
ResGob$Valor=NULL
write.csv(ResGob, file = "Restriccion_Limpia.csv", row.names = F)
Rigurosidad=import("Restriccion_Limpia.csv")
str(Rigurosidad$StringencyIndex)
```

